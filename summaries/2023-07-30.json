{
  "summary": [
    {
      "summary": "This post is an update and reflection on a community process that was introduced last year. The author mentions the failure of the CTV speedy trial activation and the ongoing discussions about covenant proposals. The purpose of the community process is to specify covenants and address issues in consensus development changes. The goals include building a framework to evaluate covenant proposals, finding common grounds between proposals, and opening up the consensus changes development process beyond the historical boundaries of Bitcoin Core.\n\nThe author acknowledges other complementary initiatives that have been undertaken during the same period, such as the bitcoin-inquisition fork and the careful archiving of all covenant proposals. The Bitcoin Contracting Primitives Working Group (WG) was started to document and archive all the primitives and corresponding protocols related to Bitcoin contracting. The WG has had several monthly meetings with attendees representing different parts of the community.\n\nThe author states that they have been busy with Lightning-side and other Bitcoin projects, so they haven't been able to dedicate as much time to the community process. They believe that working on the robustness of the Lightning Network is more critical for Bitcoin's survival and will allocate their time and energy accordingly.\n\nThe author encourages others who have been working on covenant changes proposals to continue their work. They believe that incremental changes can improve self-custody solutions and lower the technical consensus bar. They also mention their own plans to continue researching and developing CoinPool, as well as submitting security reviews of consensus changes under pseudonyms.\n\nThe author acknowledges that they may have overpromised with the kickstart of the community process but believes that enough sessions have been conducted to demonstrate its value. They believe that what Bitcoin lacks is a small crowd of technical historians and archivists to assess and preserve consensus changes proposals, as well as QA devs to ensure proper testing before deployment.\n\nIn the conclusion, the author invites others to continue maintaining and nurturing the Bitcoin Contracting Primitives WG or collaborate with other initiatives. They express their willingness to support such efforts if there is proof of work, operational ground, legal information, or financial resources to anchor the work on the long-term.\n\nOverall, the post provides an update on the community process for specifying covenants and reflects on the author's personal priorities and commitments in Bitcoin development.",
      "summaryeli15": "This message was written by someone named Antoine and was posted on a Bitcoin development mailing list. Antoine is discussing their idea for a new community process to specify covenants, which are essentially rules or conditions that need to be met in order for a transaction to be valid on the Bitcoin network.\n\nAntoine begins by summarizing the goals of their proposal, which include building a framework to evaluate covenant proposals, finding common ground between different proposals, and opening up the consensus development process beyond Bitcoin Core (the main software implementation of Bitcoin). They also mention the importance of maintaining a high-quality technical archive for consensus discussions.\n\nThey mention that their proposal was a response to issues pointed out by Jeremy Rubin, who criticized the lack of a \"codified checklist\" for consensus changes and emphasized that Bitcoin Core is not Bitcoin itself. Antoine acknowledges the technical concerns raised by Rubin but also mentions their own limited understanding of certain aspects related to vaults and payment pools.\n\nAntoine goes on to discuss other related initiatives that have been undertaken, such as the bitcoin-inquisition fork and the archiving of covenant proposals under the Optech umbrella.\n\nThey mention the Bitcoin Contracting Primitives Working Group, which they started to archive and document various primitives and protocols related to Bitcoin contracts. They mention that the group has had monthly meetings and in-depth discussions on topics like payment pools and \"merkelized all the things.\"\n\nAntoine admits that they have not been actively involved in the group since April due to other commitments, but they still believe that the process has value. However, they express that their priority lies in working on Lightning Network development, as they believe it is critical for Bitcoin's survival.\n\nAntoine encourages others to continue working on covenant changes proposals and mentions that small incremental changes can be beneficial. They also mention their own plans to work on R&D for CoinPool, focusing on interactivity issues and advanced Bitcoin contracts based on the taproot annex.\n\nThey also mention the possibility of submitting security reviews of consensus changes under pseudonyms and suggest using Greg Maxwell's joinpool for payment pool deployment.\n\nAntoine acknowledges that they may have overpromised with their proposal but believes that enough sessions and technical interests have been collected to show the value of the process. They suggest that what Bitcoin really lacks is a group of technical historians and archivists to assess and preserve consensus changes proposals.\n\nThey invite others to continue maintaining and nurturing the Bitcoin Contracting Primitives WG and other related initiatives and express their willingness to support those who have a long-term commitment to the work.\n\nOverall, Antoine's message addresses their proposal for a new community process for covenants in Bitcoin, highlights related initiatives, discusses their personal focus on Lightning Network development, and encourages others to continue working on consensus changes proposals.",
      "title": "On the experiment of the Bitcoin Contracting Primitives WG and marking this community process \"up for grabs\"",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021786.html"
    },
    {
      "summary": "The text you provided describes the implementation of a version of the 2-of-2 Schnorr Musig2 protocol for statechains. In this protocol, there are two parties involved, referred to as Party 1 and Party 2.\n\nThe goal of this implementation is to ensure that Party 1 is fully \"blinded\", meaning that it does not have access to certain sensitive information while still being able to participate in the protocol and generate a signature.\n\nThe specific details of this implementation are as follows:\n\n1. Party 1 generates a private key (x1) and a corresponding public key (X1 = x1G), where G is the generator point of the elliptic curve used.\n2. Party 2 also generates a private key (x2) and a public key (X2 = x2G).\n3. The set of public keys involved in the protocol is denoted as L = {X1, X2}.\n4. The key aggregation coefficient is calculated as KeyAggCoef(L, X) = H(L, X), where H is a hash function. This coefficient is used to compute the aggregate public key X = a1X1 + a2X2, where a1 = KeyAggCoef(L, X1) and a2 = KeyAggCoef(L, X2).\n5. To sign a message (m), Party 1 generates a nonce (r1) and computes R1 = r1G.\n6. Similarly, Party 2 generates a nonce (r2) and computes R2 = r2G.\n7. These two nonces are aggregated to compute R = R1 + R2.\n8. Party 1 then computes a \"challenge\" value (c) as c = H(X || R || m) and calculates s1 = c.a1.x1 + r1.\n9. Party 2 also computes the challenge value as c = H(X || R || m) and calculates s2 = c.a2.x2 + r2.\n10. The final signature is then represented as (R, s1 + s2).\n\nIn the case of blinding Party 1, the goal is to prevent Party 1 from knowing the full public key, the final signature, or the message being signed.\n\nTo achieve this, a few modifications are made:\n\n1. Key aggregation is performed only by Party 2. Party 1 simply sends its public key (X1) to Party 2.\n2. Nonce aggregation is also performed only by Party 2. Party 1 sends its nonce (R1) to Party 2.\n3. Party 2 calculates the challenge value (c) as c = H(X || R || m) and shares it with Party 1. Party 1 uses this challenge value to compute its own partial signature (s1).\n\nBy implementing these changes, Party 1 remains blinded and does not have access to the full public key, the final signature, or the message being signed.\n\nThe document ends with a request for comments or potential issues regarding this implementation.\n\nPlease note that the text you provided appears to be part of a larger communication, and the HTML attachment mentioned at the end was not included.",
      "summaryeli15": "This text is explaining a cryptographic protocol called 2-of-2 Schnorr Musig2. The protocol is being implemented for a system called statechains, where the server (referred to as \"party 1\") wants to be fully \"blinded\" in the process. Being blinded means that party 1 will hold a private key needed to generate an aggregate signature on an aggregate public key, but it will not have knowledge of certain important elements.\n\nIn this version of the protocol, party 1 wants to ensure that it does not learn the following information: 1) The aggregate public key, which is a combination of multiple public keys, 2) The aggregate signature, which is the final signature generated by all parties involved, and 3) The specific message (m) being signed.\n\nThe security of this implementation relies on party 1 being trusted to report the number of partial signatures it has generated for a particular key, rather than being trusted to enforce rules on what it has signed in the unblinded case. The full set of signatures generated is then verified on the client side.\n\nNow, let's dive into the actual protocol. Here is how the 2-of-2 musig2 protocol operates:\n\n1. Party 1 generates a private key (x1) and a public key (X1 = x1G). \n2. Party 2 also generates a private key (x2) and a public key (X2 = x2G).\n3. The set of public keys is denoted as L = {X1, X2}.\n4. The key aggregation coefficient is calculated as KeyAggCoef(L, X) = H(L, X), where H is the hash function.\n5. The shared (aggregate) public key (X) is computed as X = a1X1 + a2X2, where a1 = KeyAggCoef(L, X1) and a2 = KeyAggCoef(L, X2).\n6. To sign a message (m), party 1 generates a random nonce (r1) and calculates R1 = r1G.\n7. Similarly, party 2 generates a random nonce (r2) and obtains R2 = r2G.\n8. The nonces are then aggregated as R = R1 + R2.\n9. Party 1 computes the 'challenge' (c) as c = H(X || R || m) and calculates s1 = c.a1.x1 + r1.\n10. Party 2 also computes the 'challenge' (c) as c = H(X || R || m) and calculates s2 = c.a2.x2 + r2.\n11. The final signature is then represented as (R, s1 + s2).\n\nNow, in the case of blinding this protocol for party 1, the goal is to prevent party 1 from learning the full public key or the final signature. To achieve this, the following steps are taken:\n\n1. Key aggregation is performed only by party 2. Party 1 simply sends its public key (X1) to party 2.\n2. Nonce aggregation is also performed only by party 2. Party 1 only needs to send its nonce (R1) to party 2.\n3. Party 2 computes the 'challenge' (c) as c = H(X || R || m) and sends it back to party 1. Party 1 then uses this challenge to calculate s1 = c.a1.x1 + r1.\n4. Ultimately, party 1 never gains knowledge of the final value of (R, s1 + s2) or the message (m).\n\nThis approach ensures that party 1 remains blinded throughout the process, without obtaining information about the aggregate public key, the aggregate signature, or the specific message being signed.\n\nIf you have any further questions or need clarifications, feel free to ask.",
      "title": "Blinded 2-party Musig2",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021792.html"
    },
    {
      "summary": "This passage discusses a method for computing blinding factors in a cryptographic protocol called Trampoline Routing. The goal of Trampoline Routing is to allow for secure and private routing of information through intermediary nodes without these nodes being aware that they are part of a trampoline path.\n\nThe passage begins by describing the scenario where the ultimate receiver has a secret value `r` and provides the ultimate sender with a point `R`, computed as `R = r * G`, where `G` is a known point on a curve. In this case, the ultimate sender can generate an error blinding factor `e` and construct an onion encryption with `e` decryptable by the ultimate receiver. The ultimate sender also offers a PTLC (Payment Tokenized Lightning Channel) with the point `e * G + R`. The ultimate receiver can then claim this PTLC by revealing `e + r`, as it knows `e` from the onion and it has the contract to give `r` in exchange for payment.\n\nNext, the passage explores the scenario where the ultimate receiver needs to go through an intermediate node called Carol. In this case, the ultimate sender needs to generate two scalars `c` and `d` such that `c + d = e`, where `e` is still the error blinding factor. The ultimate sender encrypts the onion with `e` encrypted to the ultimate receiver and `d` encrypted to Carol. The PTLC sent to Carol has the point `c * G + R`. Carol then adds `d * G` to the received point and sends a PTLC with the point `c * G + R + d * G` to the next hop. Importantly, the PTLC sent by Carol can be rearranged to be `(c + d) * G + R`, which is equal to `e * G + R`. As a result, the ultimate receiver cannot determine whether it received the PTLC from Carol or from a further node.\n\nFinally, the passage considers the scenario where Carol is a Trampoline node, and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop. The ultimate sender still selects a random `e` and generates `c` and `d` such that `c + d = e`. It then creates a Trampoline-level onion with `e` encrypted to the ultimate receiver and `d` encrypted to Carol. Carol decrypts the onion and finds a route from Carol to the ultimate receiver (the next Trampoline hop). Carol selects two scalars `a` and `b`, with `a + b = d`, and creates a new onion with `b` encrypted to Alice. This process continues until the ultimate receiver is reached. In the end, the ultimate receiver receives the same `e * G + R` point and cannot differentiate between Trampoline and non-Trampoline routes.\n\nIn conclusion, this passage provides a detailed explanation of a method for computing blinding factors in Trampoline Routing. It shows how the ultimate sender can construct onions and PTLCs in a way that maintains privacy and allows for secure routing through intermediate nodes.",
      "summaryeli15": "Sure! Let's break it down step by step:\n\n1. Scenario: In this example, we have an \"ultimate receiver\" who has a secret value called \"r\".\n\n2. The receiver shares a point called \"R\" with the \"ultimate sender\" in such a way that R = r * G. (G is a predefined point on a curve)\n\n3. Simple Case: When the ultimate sender is directly connected to the ultimate receiver, it chooses a random value called \"e\" (error blinding factor) and constructs an onion with e that can be decrypted by the ultimate receiver. Along with the onion, the ultimate sender offers a \"point-time-lock-contract\" (PTLC) with the point (e * G + R). The ultimate receiver can unlock this contract by revealing (e + r), as they learn \"e\" from the onion and they need to provide \"r\" in exchange for payment.\n\n4. Intermediate Node: Now let's say there is an intermediate node, called \"Carol\", between the ultimate sender and the ultimate receiver. In this case, the ultimate sender still chooses \"e\" randomly but it also generates two scalars, \"c\" and \"d\", such that (c + d = e). This is done by randomly selecting \"d\" and calculating \"c = e - d\". The ultimate sender then encrypts the onion with \"e\" for the ultimate receiver and encrypts the ciphertext, along with \"d\", for Carol.\n\n5. Non-Trampoline Nodes: Each non-Trampoline intermediate node, like Carol, receives the input point (c * G + R), adds its per-hop blinding factor times G to it, and uses the result as the output point to the next hop. So Carol receives (c * G + R), adds (d * G) to it (which it got from the onion), and then sends a PTLC with the point (c * G + R + d * G). Note that (e = c + d), so the PTLC sent by Carol is equal to (e * G + R).\n\n6. Ultimate Receiver's Perspective: The ultimate receiver, in both the direct and indirect cases, sees the point (e * G + R). It cannot differentiate whether it received from Carol or a further node because the point remains the same.\n\n7. Claiming and Privacy: When the ultimate receiver releases (e + r), Carol can compute (c + r) by taking (e + r - d). Since (c = e - d), (e + r - d = e - d + r = c + r). Carol can then claim the incoming (c * G + R) with scalar (c + r). Carol does not know \"c\", it only knows \"d\", so it cannot compute \"r\". This ensures privacy.\n\n8. Trampoline Node: Now let's consider the scenario where Carol is a Trampoline node and the ultimate sender does not provide a detailed route from Carol to the next Trampoline hop.\n\n9. Ultimate Sender: The ultimate sender learns \"R\" and selects a random \"e\". It also selects \"c\" and \"d\" such that (c + d = e), using the same technique as before. It then creates a Trampoline-level onion with \"e\" encrypted for the ultimate receiver and the ciphertext, \"d\", and the next Trampoline hop encrypted for Carol.\n\n10. Carol's Role: Carol decrypts the onion and obtains \"d\". It then searches for a route from Carol to the ultimate receiver (the next Trampoline hop). Let's say Carol finds a route Carol -> Alice -> ultimate receiver.\n\n11. Creating the Onion: Carol selects two scalars, \"a\" and \"b\", such that (a + b = d). It knows \"d\" and can randomly pick \"b\" and compute \"a = d - b\". Carol creates the onion with the copied ciphertext from the ultimate sender, \"e\" encrypted for the ultimate receiver, and the ciphertext and \"b\" encrypted for Alice.\n\n12. PTLC Sent to Alice: Carol sends the PTLC with the point (c * G + R + a * G) to Alice. Alice decrypts the onion and learns \"b\". Forwarding, Alice sends the PTLC with the point (c * G + R + a * G + b * G) to the next hop, the ultimate receiver.\n\n13. Mathematical Manipulation: We know that (a + b = d), so (a * G + b * G = d * G). Also, (c + d = e), so (c * G + d * G = e * G). Thus, we have: c * G + R + a * G + b * G = c * G + a * G + b * G + R (commutative property) = c * G + (a + b) * G + R (associative property) = c * G + d * G + R (d = a + b by construction) = (c + d) * G + R (associative property) = e * G + R (e = c + d by construction)\n\n14. Ultimate Receiver's Perspective (Again): The ultimate receiver receives the same (e * G + R) as before and cannot differentiate whether it was reached via a Trampoline, via a non-Trampoline intermediate, or directly.\n\n15. Claiming and Privacy (Again): Each intermediate node, both Trampoline and non-Trampoline, has enough data to claim its incoming PTLC. Only the ultimate sender knows \"c\", which allows it to recover the \"r\".\n\nHope this clears things up! Let me know if you have any further questions.",
      "title": "Computing Blinding Factors in a PTLC and Trampoline World",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html"
    },
    {
      "summary": "In this message, the sender (presumably a member of the LNbits team) is notifying the recipients (referred to as \"list\") about an interesting exploit that was discovered by their team. This exploit allowed an attacker to create balances out of thin air by taking advantage of a quirk in how invoices are handled internally. The team has already fixed this exploit in LNbits version 0.10.5 and is urging everyone to update as soon as possible if they haven't done so already.\n\nThe sender wants to describe the attack in detail because they believe that a similar exploit could be possible in other Lightning applications. They specifically mention custodial wallets, payment processors, and account management software as examples of applications that should pay attention to this. They want to emphasize that the attack they discovered could potentially be carried out in other applications as well.\n\nThe attack itself involved the attacker inserting a bolt-11 payment hash of payment A into a different payment, thus creating a malicious invoice B that tricks the backend into believing that B is equal to A. The following steps outline the process of the attack:\n\n1. The attacker creates invoice A with an amount of 1000 sat (satoshi) in LNbits.\n2. The attacker also creates invoice B' with an amount of 1 sat on their own node.\n3. The attacker then deserializes invoice B', inserts the payment_hash of payment A into payment_hash of payment B, re-signs the invoice, and serializes it again, resulting in the creation of a malicious invoice B.\n4. The attacker creates a new account in LNbits and pays invoice B.\n5. The LNbits backend uses payment_hash of invoice B to check whether this is an internal payment or a payment via LN (Lightning Network).\n6. The backend finds payment A in its database because it assumes that payment_hash of A commits to payment A. This assumption is the critical part of the attack.\n7. The backend settles the payment internally by crediting payment A and debiting payment B.\n8. As a result, the attacker has effectively \"created\" 999 sat.\n\nTo mitigate this exploit, the sender suggests a simple solution. Backends should either use self-generated unique \"checking ids\" for looking up internal payments or implement additional checks to ensure that the invoice details have not been tampered with (e.g., verifying that the amounts of A and B are the same).\n\nThe sender also highlights two important lessons from this exploit. Firstly, it is crucial to recognize the level of sophistication of attackers who are well-versed in Lightning Network (LN) technology. This attack required a fundamental understanding of bolt-11 (a Lightning Network invoice format) and custom tools to create the malicious invoice. Secondly, the sender emphasizes that the \"payment hash\" of an invoice should be referred to as a \"preimage hash\" to avoid any implicit assumption that the hash commits to payment details like the amount or public key.\n\nIn summary, the sender raises awareness about an exploit they discovered and urges recipients to update their LNbits software. They provide a detailed explanation of the attack, suggest a mitigation strategy, and highlight important lessons learned from this incident.",
      "summaryeli15": "Dear 15-year-old,\n\nEarlier last month, our team at LNbits discovered a very interesting exploit that could have allowed an attacker to create balances out of thin air by taking advantage of a quirk in how invoices are handled internally. We have fixed this issue in LNbits version 0.10.5 and strongly recommend that you update your software as soon as possible if you haven't done so already. I want to explain the attack in detail here because I believe that it may be possible to carry out a similar exploit in other Lightning applications. If you are working on custodial wallets, payment processors, account management software, or anything similar, you should pay attention to this.\n\nIn short, the attacker found a way to insert a payment hash of payment A into a different payment, creating a malicious invoice B that can trick the backend into thinking that B is equal to A. Let's break down the steps of the attack:\n\n1. The attacker creates invoice A with an amount of 1000 sat in LNbits.\n2. The attacker then creates invoice B' with an amount of 1 sat on her own node.\n3. The attacker deserializes invoice B', which means she breaks down the invoice into its individual components.\n4. The attacker inserts the payment hash of invoice A into the payment hash field of invoice B.\n5. The attacker re-signs the modified invoice B and serializes it again, creating the malicious invoice B.\n6. The attacker creates a new account in LNbits and pays the malicious invoice B.\n7. The LNbits backend uses the payment hash of invoice B to check whether this payment is internal or through the Lightning Network.\n8. The backend finds invoice A in its database because it assumes that the payment hash of invoice A commits to invoice A itself. This is the critical part where the exploit happens! It's crucial to understand that payment hashes only commit to the preimage and not to any payment details like the amount.\n9. The backend settles the payment internally by crediting invoice A and debiting invoice B.\n10. The attacker has effectively \"created\" 999 sats out of thin air.\n\nTo mitigate this exploit, it is quite simple. Backends should either use self-generated unique \"checking ids\" to look up internal payments or implement additional checks to ensure that the invoice details have not been tampered with. For example, they can compare the amounts of invoices A and B to make sure they are the same.\n\nFrom this incident, we can learn two important lessons. First, we need to be aware of the level of sophistication that attackers with knowledge of Lightning Network technology can possess. This attack required a deep understanding of bolt-11 and custom tools to produce the malicious invoice. Second, we should understand that the \"payment hash\" of an invoice is not actually a \"payment\" hash but simply a \"preimage\" hash. It doesn't commit to payment details like the amount or the public key. To avoid confusion, I will be calling it the \"preimage hash\" from now on and I encourage you to do the same.\n\nI hope this explanation helps you understand the nature of the exploit and its implications. If you have any further questions, feel free to ask.\n\nBest,\nCalle",
      "title": "Potential vulnerability in Lightning backends: BOLT-11 \"payment hash\" does not commit to payment!",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html"
    },
    {
      "summary": "Certainly! This message is written by someone who wants to share a side project they have been working on. The goal of this project is to collect data on the lightning network, which is a network that facilitates fast and cheap Bitcoin transactions. The author wants to study how the network is evolving over time and also evaluate different proposals or ideas, such as \"channel jamming,\" which may have an impact on the network's performance.\n\nThe author believes that having real data rather than relying solely on simulation results can provide better insights into how these proposals or ideas might affect the network. Additionally, the author wants to support university research by providing access to this real data, which might not be readily available otherwise.\n\nTo achieve this, the author has developed a detailed plan for defining and collecting information about the lightning network. They have provided a link to a GitHub repository [1], which contains a more comprehensive explanation of this idea. The author has also built an experimental explorer [2], where one can visualize and explore the collected data. Additionally, they have exposed a public Graphql API [3], which allows others to access and use the collected data for their research or evaluation purposes.\n\nIn conclusion, the author hopes that their project will be helpful to someone who is interested in understanding and improving the lightning network. The provided links serve as resources for anyone who wants to learn more about this project or access the collected data. The author signs off as Vincent.",
      "summaryeli15": "Hi there! I'd be happy to explain this in detail.\n\nThis person is talking about a side project they've been working on related to the Lightning Network. The Lightning Network is a second layer solution built on top of the Bitcoin blockchain that aims to make transactions faster and cheaper.\n\nIn this project, the person is focused on collecting data on the Lightning Network. They want to track how the network evolves over time and evaluate potential solutions to issues that might arise, such as channel jamming. Channel jamming is when a channel in the network becomes congested with too many transactions, leading to delays and higher fees.\n\nRather than relying solely on simulations, the person wants to gather real-world data to understand the actual impact of different proposals. They also want to support university research that may not have access to this type of data.\n\nTo achieve this, they have come up with an idea to define and collect specific information about the network. This information can then be shared with others for evaluation and discussion of new ideas or proposals.\n\nTo explore this idea further, they have provided links to a more detailed explanation of their idea [1], an experimental explorer [2], and a public Graphql API [3]. The experimental explorer allows users to interactively explore and analyze data related to the Lightning Network.\n\nThe person hopes that their project will be useful to others who are interested in studying, analyzing, and proposing solutions for the Lightning Network.\n\nI hope this explanation helps! Let me know if you have any further questions.",
      "title": "An Open Source Framework to Collect Lightning Network Metrics",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004011.html"
    },
    {
      "summary": "- In this message, the sender provides a detailed summary of the topics discussed at a recent specification meeting in NYC.\n- The meeting focused on various aspects of the Lightning Network protocol, including package relay, taproot, gossip, and channel jamming mitigation.\n- Package Relay:\n  - The current proposal for package relay is ancestor package relay.\n  - Package relay allows for easier inclusion of transactions in the mempool.\n  - The proposal includes the use of ephemeral anchors and zero fee commitments.\n  - The changes aim to improve transaction relay, minimize pinning attacks, and simplify the mempool policy.\n- Taproot:\n  - Taproot is still in draft phase, but the code is ahead of the test vectors.\n  - The biggest change is around anchors, which become more complicated with taproot.\n  - The proposal suggests using NUMS points for to_remote keys and simplifying the revocation path on to_local keys.\n- Gossip:\n  - The discussion revolved around version 1.5 vs version 2 of gossip.\n  - Version 1.5 allows for loose script binding, while version 2 allows for any taproot output to be a channel.\n  - The participants debated whether to fully bind to the script or allow more flexibility.\n  - The consensus was that any taproot output should be allowed to be a lightning channel.\n- Channel Jamming Mitigation:\n  - The participants discussed different methods to mitigate channel jamming attacks, including monetary incentives, reputation systems, and scarce resource allocation.\n  - A hybrid approach that combines unconditional fees and reputation systems was suggested as a possible solution.\n  - The discussion also covered the idea of resource bucketing and how it can limit the number of slots and liquidity available for nodes with low reputation.\n- Simplified Commitments:\n  - The idea of simplified commitments was proposed to make the state machine of the Lightning Network protocol easier to understand.\n  - The proposal suggested adding turn taking between channel parties to simplify the process of updating commitments.\n  - The participants also discussed the possibility of adding NACK and revoke messages to allow for more control over the update process.\n- Async Payments and Trampoline:\n  - The participants discussed the use of blinded payments in trampoline payments to enhance privacy.\n  - Trampoline payments allow light nodes to send payments through a few trampolines in the network, making it harder to link the sender and recipient.\n  - The idea is to give a trampoline only a blinded path, and they can handle the rest of the routing.\n  - The discussion also touched on the possibility of MPP (Multi-Path Payments) over trampoline and the need for radius-based gossip in trampoline networks.\n- Meta Spec Process:\n  - The participants discussed the need for a more structured and versioned approach to the Lightning Network specification.\n  - It was suggested to use extensions instead of a single living document to make the specification more modular and easier to follow.\n  - The participants also discussed the importance of maintaining backward compatibility and ensuring a smooth transition between different versions of the specification.\n  - The need for better communication, including the use of IRC and the lightning-dev mailing list, was also emphasized.\n- Overall, the meeting covered a wide range of topics related to the Lightning Network protocol, with a focus on improving scalability, privacy, and network security. The participants discussed various proposals and ideas, aiming to enhance the functionality and robustness of the network.",
      "summaryeli15": "During the annual specification meeting in New York City at the end of June, the attendees discussed various topics related to the Lightning Network. The meeting notes, which were transcript-style, are available in a Google document. The notes roughly follow the structure of the discussions that took place during the meeting. The speakers are not identified, and any errors in the notes are the responsibility of the person who took them.\n\nOne of the topics discussed was package relay. The current proposal for package relay is ancestor package relay, where one child can have up to 24 ancestors. The notes mentioned that package relay will make it easier to get things into the mempool, and once V3 transactions are implemented, minimum relay fees can be dropped. The notes also discussed the introduction of ephemeral anchors, which would allow getting rid of 330 sat anchors. The bigger change discussed was with HTLCs (Hash Time-Locked Contracts).\n\nThe notes also mentioned the concept of a \"top of block\" mempool or cluster mempool, where transactions are grouped into clusters that make it easier to sort and reason about. This is the only way to achieve package Replace-By-Fee (RBF).\n\nOther topics discussed during the meeting include Taproot, Gossip V1.5 vs V2, multi-sig channel parties, PTLCs (Path-based Timelock Contracts), and a hybrid approach to channel jamming. The participants also talked about reputation systems for channel jamming mitigation and the possibility of simplified commitments to make the Lightning Network state machine easier to understand.\n\nThe participants acknowledged the need for a more structured approach to the Lightning Network specification process and considered options such as versioning to make the protocol more modular and maintainable. They also discussed the use of asynchronous payments and the trampoline routing scheme, where recipients only provide the next trampoline in the path of the payment, allowing for improved privacy.\n\nIn conclusion, the meeting covered a range of topics related to the Lightning Network, including package relay, mempool optimization, anchors, HTLCs, Taproot, reputation systems, simplified commitments, and trampoline routing. The participants considered ways to improve the specification and discussed potential future developments for the network.",
      "title": "LN Summit 2023 Notes",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004014.html"
    }
  ]
}