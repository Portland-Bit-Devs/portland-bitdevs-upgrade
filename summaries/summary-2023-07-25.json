{
  "summary": [
    {
      "summary": "This message is from Michael Ford, sent on May 26, 2023, at 11:39:17 AM +0100. Michael Ford is informing the recipients about the availability of Bitcoin Core version v25.0. The download link for this version is provided, which is https://bitcoincore.org/bin/bitcoin-core-25.0/. \n\nAdditionally, the source code for this version is available on GitHub at https://github.com/petertodd/bitcoin/tree/full-rbf-v25.0. Users can clone this repository using the command \"git clone -b full-rbf-v25.0 https://github.com/petertodd/bitcoin.git\".\n\nThe message then explains what Bitcoin Core v25.0 is. It mentions that it includes Antoine Riard's full-rbf peering code, along with some minor updates. Full-rbf stands for full Replace-By-Fee, and it has two features for nodes running it:\n\n1) When the configuration parameter \"mempoolfullrbf\" is set to 1, it advertises a FULL_RBF service bit. This indicates that the node supports full-rbf.\n\n2) It connects to four additional FULL_RBF peers. This ensures that a core group of nodes are consistently propagating full-rbf replacements.\n\nThe author clarifies that not everyone needs to run this version, but it would be helpful if more people did. To understand why running full-rbf is recommended, the author directs readers to a blog post at https://petertodd.org/2023/why-you-should-run-mempoolfullrbf.\n\nThe message concludes with a playful mention of having hats related to this topic, with a link to a tweet showing the hats.\n\nAdditionally, there is a non-text attachment in the email, named \"signature.asc\", which is likely the sender's digital signature. The size of the signature is 833 bytes, and there is no URL provided for it.",
      "summaryeli15": "This message is from Michael Ford via the Bitcoin development mailing list. He is announcing the availability of Bitcoin Core version v25.0. The software can be downloaded from the official Bitcoin Core website (bitcoincore.org) or from a specific branch (full-rbf-v25.0) on the GitHub repository (github.com/petertodd/bitcoin). You can use the git clone command to download it.\n\nSo, what is this? Bitcoin Core v25.0 is a specific version of the Bitcoin software that includes a feature called \"full-rbf peering code\" developed by Antoine Riard. Additionally, there are some minor updates to this feature. \"Full-rbf\" stands for \"full replace-by-fee,\" which is a method of updating a Bitcoin transaction by paying a higher fee for faster confirmation. By running this version of the software, it allows you to do two things if you enable a setting called \"mempoolfullrbf=1\":\n\n1) It advertises that your node supports full replace-by-fee transactions by setting a service bit called FULL_RBF.\n2) It connects to four other nodes that also support full replace-by-fee transactions.\n\nBy doing these two things, the core group of nodes that run the full-rbf feature can reliably propagate transactions that use full replace-by-fee. It is not necessary for everyone to run this version, but it would be helpful if more people did. If you're wondering why you should run full-rbf, Michael Ford suggests reading a blog post by Peter Todd, which provides more information on the benefits (petertodd.org/2023/why-you-should-run-mempoolfullrbf).\n\nLastly, Michael Ford mentions that there are even hats available related to this release, which you can see in a tweet by Peter Todd (twitter.com/peterktodd/status/1659996011086110720/photo/1).",
      "title": "Full-RBF Peering Bitcoin Core v25.0 Released",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021729.html"
    },
    {
      "summary": "The message is from the LNP/BP Standards Association, who previously introduced the RGB smart contract system. They state that client-side validation has the potential to upgrade the Bitcoin layer 1 blockchain, which is currently causing scaling and privacy issues for the Bitcoin ecosystem. However, they believe that this layer can be implemented more efficiently than the existing blockchain.\n\nThe LNP/BP Standards Association now presents a proposal called Prime, which aims to upgrade the Bitcoin protocol with a new layer 1. This upgraded layer would be scalable, capable of handling billions of transactions per minute, and fully anonymous (opaque). The proposal suggests moving most validation work to a client-side validation system, while keeping Bitcoin as money and the rest of the Bitcoin ecosystem intact.\n\nThey claim that Prime can be deployed without a softfork or requiring miners to upgrade, but it can benefit from those upgrades if they happen. The upgrade does not force users to upgrade their system, and its initial deployment does not require any consensus or majority. They also believe that Lightning Network and other layer 2 systems will no longer be necessary with the implementation of Prime.\n\nAdditionally, the proposal states that with Prime, things like BRC20, inscriptions, and ordinals will no longer be possible. Instead, proper assets and non-fungible tokens (NFTs) will be managed through RGB smart contracts. This prevents non-users from having to store, validate, and use their network bandwidth for third-party interests.\n\nThe white paper detailing the Prime proposal can be found on the LNP/BP Standards Association's GitHub page. They mention that they are forming a working group to focus on formal specification and reference implementation of this new layer. They invite anyone interested to join the working group and cooperate on this topic.\n\nThe association also plans to conduct educational and workshop activities to help the community better understand the technology behind Prime and make informed decisions about its adoption. They emphasize that this infrastructure effort should be managed by a non-profit organization, and funding for the project will come from non-profit donations. They announce their plan to launch a fundraising campaign and invite anyone interested in driving the evolution of Bitcoin to contact them.\n\nFor-profit organizations can also become members of the LNP/BP Standards Association and participate in shaping the future of Bitcoin technologies through committee involvement.\n\nThe message provides various links for further information and contact details, including the LNP/BP Standards Association's website, GitHub page, and Twitter account.",
      "summaryeli15": "In this announcement, the LNP/BP Standards Association is introducing a new system called RGB smart contract system. They believe that the current Bitcoin blockchain, which is the underlying technology of Bitcoin, has limitations that are impacting the scalability and privacy of the Bitcoin ecosystem. To address these limitations, they propose an upgrade to the Bitcoin protocol called Prime.\n\nPrime aims to make the Bitcoin protocol more scalable and anonymous by moving most of the validation work to a client-side validation system. This means that the validation process, which involves verifying the authenticity and accuracy of transactions on the blockchain, will be carried out by individual users rather than relying solely on the Bitcoin blockchain.\n\nThe proposed upgrade does not require a softfork (a backwards-compatible upgrade) or miners to upgrade their systems. However, it can still benefit from these upgrades if they occur. Users who choose not to upgrade will not be affected, and there is no need for consensus or majority agreement for the initial deployment of Prime.\n\nThe introduction of Prime will also make layer 2 systems like the Lightning Network redundant. Layer 2 systems are built on top of the Bitcoin blockchain and are used to improve scalability and transaction speed. With Prime, these layer 2 systems will no longer be necessary.\n\nAdditionally, Prime will render certain functionalities like BRC20, inscriptions, and ordinals impossible. These functionalities are related to blockchain-based assets and contracts. Instead, Prime proposes to handle these functionalities through RGB smart contracts, which are more efficient and do not burden non-users with storing, validating, and using network bandwidth for third-party interests.\n\nThe announcement provides a link to a white paper that describes the Prime proposal in more detail. The LNP/BP Standards Association is forming a working group to develop the formal specification and reference implementation of Prime. They encourage anyone interested in contributing to join the working group.\n\nThe Association also emphasizes their belief that this infrastructural effort should not be managed by a for-profit company. They suggest that funding for this project should come from non-profit donations. They plan to launch a fundraising campaign and invite anyone interested in driving the evolution of Bitcoin to contact them.\n\nFor-profit organizations are also invited to become members of the Association and participate in shaping the future of Bitcoin technologies through committee involvement.\n\nOverall, the LNP/BP Standards Association is proposing an upgrade to the Bitcoin protocol called Prime that aims to improve scalability and privacy by moving validation work to the client-side. They believe this upgrade will make other layer 2 systems unnecessary and enable more efficient handling of blockchain-based assets and contracts through RGB smart contracts.",
      "title": "Scaling and anonymizing Bitcoin at layer 1 with client-side validation",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021732.html"
    },
    {
      "summary": "This email is a discussion about the MATT proposal for smart contracts in Bitcoin. The author, Salvatore Ingala, provides some updates on the progress of formalizing the semantics of the core opcodes of MATT and demonstrates how these opcodes can be used to create vaults that are comparable to the ones built with OP_VAULT.\n\nThe core opcodes of MATT are OP_CHECKINPUTCONTRACTVERIFY and OP_CHECKOUTPUTCONTRACTVERIFY. These opcodes enhance the Script language by allowing the embedding of data in an output and the ability to read that embedded data in the current UTXO.\n\nThe opcodes have specific functionalities. OP_CHECKINPUTCONTRACTVERIFY verifies that the current input's internal key contains some embedded data, and OP_CHECKOUTPUTCONTRACTVERIFY verifies that a given output contains the desired embedded data.\n\nThe email discusses the semantics and implementation of these opcodes in detail, providing code examples and explanations. It also mentions potential extensions and improvements to the opcodes, such as adding an opcode for multiple pieces of embedded data and allowing OP_CHECKOUTPUTCONTRACTVERIFY to apply to an arbitrary input.\n\nThe second part of the email focuses on using MATT to build vaults. The author describes a vault as a simple state machine with two states: [V] (the initial vault UTXO) and [U] (the unvaulting UTXO). The author explains how the opcodes can be used to define the scripts and conditions for these states. The email provides examples of the P2TR structure for both the [V] and [U] states, including the scripts and witness data required for each state.\n\nThe author also discusses the differences between MATT vaults and vaults based on OP_VAULT. One notable difference is that MATT vaults do not have an option to add an additional output that is sent back to the same vault, unlike OP_VAULT vaults. The author explains that MATT vaults handle the distribution of amounts differently and avoid the need for dynamically creating taptrees and replacing leaves in covenant-encumbered UTXOs.\n\nOverall, the email provides a detailed explanation and update on the MATT proposal, discussing the core opcodes, their semantics, and their usage in building vaults. The author also mentions potential extensions and improvements to the proposal.",
      "summaryeli15": "In this email exchange, Salvatore Ingala is discussing the MATT proposal for smart contracts in Bitcoin. MATT stands for Minimally Augmented Taproot Transactions. Salvatore explains that the core functionality of MATT is quite simple and can be adapted to any version of the scripting system. The proposal introduces two new opcodes: OP_CHECKINPUTCONTRACTVERIFY and OP_CHECKOUTPUTCONTRACTVERIFY.\n\nThese opcodes allow the user to embed data in the output of a transaction and specify the script for that output. The embedded data can be accessed in future transactions using the OP_CHECKINPUTCONTRACTVERIFY opcode. The opcodes provide a form of introspection, allowing the script of an input/output to be checked against a certain value.\n\nSalvatore clarifies that MATT is part of the first bucket of proposals, which includes APO, CTV, and OP_VAULT. These proposals aim to add additional functionality to existing scripts without requiring significant changes to the underlying system.\n\nSalvatore provides example implementations and code snippets to demonstrate how MATT could be used to create vaults similar to those built with OP_VAULT. The vaults have two states: [V] and [U]. [V] represents the initial vault state, and [U] represents the unvaulted state. The opcodes are used to control the script and amount of the next step in the state machine. The user can also embed data in the output and access it in future transactions.\n\nSalvatore mentions that the implementation presented is not yet complete and needs further testing. He also discusses the potential for extending the opcodes to allow more complex contracts and the need to address the preservation of amounts in the code.\n\nIn summary, MATT is a proposal for introducing new opcodes to the Bitcoin scripting system that enable the embedding of data in transaction outputs and provide introspection capabilities. The proposal allows for the creation of vaults and other smart contracts.",
      "title": "Vaults in the MATT framework",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021730.html"
    },
    {
      "summary": "The author of this statement begins by expressing that they do not necessarily endorse the idea they are about to present, but they believe it is worth discussing for its potential to inspire different use cases or spark debate. The concept they are presenting is called \"out-of-band relay\" as an alternative and more efficient way to deliver transaction packages to miners while peer-to-peer (p2p) package relay is still in development.\n\nThey propose a scenario where there is a parent transaction, referred to as Transaction A, which has a fee rate of 0 sat/b (satoshi per byte). They also introduce a child transaction, Transaction B, which needs a fee bump in order to reach miners. Currently, both transactions cannot reach miners due to their fee characteristics.\n\nTo address this issue, the author suggests the introduction of a third transaction, Transaction C, which is specifically crafted to include both Transaction A and Transaction B within a taproot annex. The taproot annex is essentially a container for Transaction A and Transaction B. Another option the author suggests is using a commit/reveal style inscription, although they consider it to be more complex and less efficient.\n\nIn order to ensure that Transaction C propagates effectively, it would need to include sufficient fees. Additionally, Transaction C should utilize at least one of the fee-contributing inputs from Transaction B, ensuring that these inputs are not used in Transaction A. When miners receive Transaction C, they can detect the embedded transactions A and B in the annex and immediately submit them to their mempool as a transaction package. This package, consisting of transactions A and B, would then replace Transaction C and become eligible for inclusion in a block for mining.\n\nThe author emphasizes the importance of making the combined package of transactions A and B more appealing to miners than Transaction C itself. The weight of the embedded transactions in Transaction C assists in achieving this goal. Furthermore, it is worth noting that no fees will be paid for Transaction C since it has been replaced. Therefore, there are no additional costs associated with using this package relay scheme, unless the weight of transactions A and B is very low, and Transaction B needs to pay a higher fee rate than necessary to ensure the replacement of Transaction C.\n\nThere is a possibility that not all miners will adopt this incentive-compatible replacement, resulting in the mining of Transaction C. However, if the fee rate for Transaction C is kept to a minimum, it is less likely to be mined. If Transaction C does get mined, the author suggests retrying the operation with modified transactions B and C, although the fees paid for the initial Transaction C would be forfeited.\n\nIt is important to note that this statement is presented with a neutral stance, and the author provides some potential drawbacks and considerations associated with this approach. The purpose of sharing this concept is mainly to generate discussion and explore alternative methods for transaction relay in the context of blockchains.",
      "summaryeli15": "In this explanation, we'll be looking at a proposal called \"out-of-band relay\" that could potentially improve the efficiency of sending transaction packages to miners. Please keep in mind that this is just an idea and not necessarily something that should be implemented. \n\nLet's imagine a situation where there are two transactions, A and B. Transaction A is a lightning commitment transaction and it has a fee of 0 sat/b (meaning it doesn't offer any incentives for miners to include it in a block). Transaction B, on the other hand, is a fee bumping child transaction that needs to reach the miners for validation and inclusion in a block.\n\nCurrently, these types of transactions (A and B) cannot reach the miners due to some limitations with the peer-to-peer (p2p) package relay system that is still under development. So, the question arises: how can we work around this issue?\n\nOne potential solution is to introduce a third transaction, C, that is specifically crafted to contain both transactions A and B in what is called a taproot annex. Think of it as a container that holds both A and B together. Alternatively, a commit/reveal style inscription could also be used, but that might be more complex and less efficient.\n\nTo ensure that transaction C is propagated throughout the network, it would need to pay sufficient fees. Additionally, it should also use at least one of the same inputs that contribute to the fees of transaction B, but it should not include any inputs from transaction A.\n\nWhen miners receive transaction C, they can detect the embedded transactions A and B in the annex and immediately submit them to their mempool (a place where transactions sit before they are included in a block) as a transaction package. So now, instead of just transaction B, miners have both A and B together.\n\nThis newly formed transaction package (A+B) would then replace transaction C and could be included in a block for mining. It's essential to ensure that the combined package of A and B is more attractive to miners than the original transaction C. The added weight of the embedded transactions in C helps with this.\n\nIt's worth noting that the fees associated with transaction C will never be paid because it has been replaced by the combined package of A and B. So, there are no extra costs for using this package relay scheme, unless the weight of A+B is very low and B needs to pay a higher fee rate than necessary to ensure the replacement of C.\n\nHowever, it's important to consider that not all miners might adopt this replacement scheme, even though it is designed to incentivize them. In such cases, there is still a chance that transaction C ends up being mined. To minimize the likelihood of this happening, the fee rate for transaction C should be kept as low as possible.\n\nIf transaction C is indeed mined, the operation can be retried with a modified version of transactions B and C, but the fees paid for the initial transaction C would be forfeited.\n\nThis proposal, if implemented, could potentially improve the efficiency of getting transaction packages to miners while the p2p package relay system is still under development. However, it's important to consider all the potential implications, limitations, and alternative ideas before deciding whether or not to support this approach.",
      "title": "Conceptual package relay using taproot annex",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021748.html"
    },
    {
      "summary": "This message is a submission of a proposal for a new protocol called Silent Payments. The proposal aims to address the limitations of current approaches to maintaining privacy in Bitcoin transactions.\n\nThe current practice of using a new address for each Bitcoin transaction helps to maintain privacy. However, this often requires a secure interaction between the sender and receiver to exchange addresses, which is not always feasible or desirable. To solve this issue, various protocols have been proposed that use a static payment address and notifications sent via the blockchain. These protocols eliminate the need for interaction but come with drawbacks such as increased costs for one-time payments and metadata leakage.\n\nThe Silent Payments proposal intends to eliminate the need for interaction, notifications, and protect both sender and receiver privacy. However, it introduces the requirement for wallets to scan the blockchain to detect payments. This is generally feasible for full nodes but poses a challenge for light clients, although research is being conducted in this area.\n\nThe goals of the protocol are as follows:\n\n1. No increase in transaction size or cost.\n2. Transactions blend in with other Bitcoin transactions and can't be distinguished.\n3. Transactions can't be linked to a silent payment address by an outside observer.\n4. No sender-receiver interaction is required.\n5. Multiple payments from the same sender cannot be linked.\n6. Each silent payment goes to a unique address to avoid address reuse.\n7. Supports payment labeling.\n8. Uses existing seed phrase or descriptor methods for backup and recovery.\n9. Separates scanning and spending responsibilities.\n10. Compatible with other spending protocols, such as CoinJoin.\n11. Supports light client/SPV wallet.\n12. The protocol is upgradable.\n\nThe protocol is explained in detail in the message, divided into sections. The overview provides a general explanation of the protocol, and subsequent sections explain different aspects of the protocol.\n\nThe protocol enables Bob to publish a public key as a silent payment address. Alice, the sender, can then create a destination output for Bob by performing certain calculations using her private key and Bob's public key. This ensures that only Bob can detect the payment using his private key.\n\nThe protocol also allows Alice to create multiple outputs for Bob by including an integer in the calculations. This allows for multiple payments to be made without requiring additional scanning by Bob.\n\nTo prevent address reuse, Alice includes a hash of the transaction ID and output index in the calculations. This ensures that each payment generates a unique destination output.\n\nThe protocol also takes into account transactions with multiple inputs. Instead of requiring Alice to pick a specific input, she performs calculations with the sum of the input public keys. This reduces Bob's scanning requirement and improves support for light clients and collaborative transaction protocols like CoinJoin.\n\nTo protect Bob's private key during scanning, he can publish an address that includes both a scanning key and a spending key. This allows him to keep the spending key offline while performing scanning with the scanning key.\n\nThe protocol also supports labeling of payments. Bob can differentiate incoming payments by including an integer in the calculations. This helps him determine the source of each payment without the need for multiple silent payment addresses.\n\nBob can also use labeling for managing his own change outputs by reserving a secret change label. This allows him to create change outputs for himself using the silent payments protocol and the change label.\n\nOverall, the protocol aims to provide a private and efficient method of conducting Bitcoin transactions without the need for extensive interaction between the sender and receiver. It addresses the limitations of current approaches and offers several advantages while requiring some adjustments in wallet scanning and spending processes.",
      "summaryeli15": "This message is a proposal for a new feature in Bitcoin called \"Silent Payments.\" It explains the problem it aims to solve and provides an overview of how the proposed solution would work.\n\nThe problem being addressed is the need for privacy when making Bitcoin transactions. Currently, to maintain privacy, it is recommended to use a new address for each transaction. However, this often requires a secure interaction between the sender and receiver to exchange addresses. This interaction is not always feasible or desirable. As a result, various protocols have been proposed that use a static payment address and rely on notifications sent via the blockchain. While this eliminates the need for interaction, it has drawbacks such as increased costs for one-time payments and a noticeable footprint in the blockchain, which can reveal information about the sender and receiver. Additionally, notification schemes can compromise sender privacy by allowing the receiver to link all payments from the same sender.\n\nThe proposal aims to address these limitations by introducing a solution that eliminates the need for interaction and notifications while protecting both sender and receiver privacy. However, this comes at the cost of requiring wallets to scan the blockchain to detect payments. This requirement is generally feasible for full nodes but poses a challenge for light clients.\n\nThe goals of the proposed protocol are as follows:\n\n1. No increase in the size or cost of transactions.\n2. Transactions should blend in with other Bitcoin transactions and not be distinguishable.\n3. Transactions cannot be linked to a silent payment address by an outside observer.\n4. No sender-receiver interaction is required.\n5. Multiple payments from the same sender cannot be linked.\n6. Each silent payment goes to a unique address to avoid address reuse.\n7. Support for payment labeling.\n8. Use of existing seed phrase or descriptor methods for backup and recovery.\n9. Separation of scanning and spending responsibilities.\n10. Compatibility with other spending protocols, such as CoinJoin.\n11. Support for light client/SPV wallets.\n12. Upgradability of the protocol.\n\nThe overview of the protocol is then presented, starting with a simple case scenario:\n\n1. Bob publishes a public key (B) as a silent payment address.\n2. Alice, the sender, discovers Bob's silent payment address.\n3. Alice selects an Unspent Transaction Output (UTXO) with a private key (a) and a corresponding public key (A).\n4. Alice creates a destination output (P) for Bob using the equation: P = hash(a·B)·G + B, where G is the generator point for secp256k1.\n5. Alice encodes P as a BIP341 taproot output.\n6. Bob, the receiver, scans the blockchain with his private key (b) to find P by calculating P = hash(b·A)·G + B.\n7. This process allows Bob to detect incoming payments from Alice without any interaction or notifications.\n\nThe proposal also explains how to create more than one output for Bob and prevent address reuse using hash functions and indexing.\n\nFurthermore, it introduces the concept of using all inputs in Alice's transactions, reducing Bob's scanning requirements and protecting Alice's privacy in collaborative transaction protocols like CoinJoin. The protocol also addresses the issue of securely exposing Bob's private key by suggesting the use of a separate \"scan key\" for scanning incoming payments while keeping the private spend key in offline cold storage.\n\nThe proposal includes a section on labeling payments to differentiate incoming payments without requiring Bob to scan for each one separately. By labeling the spend public key (Bspend) with an integer, Bob can determine the source of an incoming payment. However, it is noted that an outside observer can easily link all labeled payment addresses to the same entity.\n\nThe proposal concludes with a mention of using labels for managing Bob's change outputs, providing an alternative to BIP32 for change management while still allowing Bob to identify which of his unspent outputs were change when recovering his wallet.\n\nOverall, the proposal aims to enhance privacy in Bitcoin transactions by introducing a protocol that eliminates the need for interaction and notifications while protecting both the sender and receiver.",
      "title": "BIP for Silent Payments",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021750.html"
    },
    {
      "summary": "In this message, ThomasV is proposing an extension to BOLT-11, which is a specification for Lightning Network invoices. The proposed extension would allow an invoice to contain two bundled payments with distinct preimages (random values) and amounts. The purpose of this extension is to address a specific use case where services require the prepayment of a mining fee in order for a non-custodian exchange to take place, such as submarine swaps and JIT (Just-In-Time) channels.\n\nSubmarine swaps and JIT channels involve a service provider receiving a Hashed Time-Lock Contract (HTLC) for which they do not have the preimage. They have to send funds on-chain, usually to a channel or submarine swap funding address, and wait for the client to reveal the preimage when they claim the payment. However, there is no guarantee that the client will actually claim the payment, which creates a need for the service providers to ask for prepayment of mining fees.\n\nIn the case of submarine swaps, services that use dedicated client software, like Loop by Lightning Labs, can ask for a prepayment because their software can handle it. This is referred to as a \"no show penalty\" on the Loop website. However, competitors who do not require a dedicated wallet, like the Boltz exchange, cannot ask for prepayment. Their website shows an invoice to the user, but it would be impractical for them to show two invoices to be paid simultaneously. This vulnerability creates a situation where Boltz is susceptible to Denial-of-Service (DoS) attacks, where an attacker forces them to pay on-chain fees.\n\nIn the case of JIT channels, providers who want to protect themselves against mining fee attacks need to ask for the preimage of the main payment before opening the channel. This makes them custodians of the funds, which has legal implications and falls within the scope of European MICA regulation. Competitors who refuse to offer custodian services, such as Electrum, are excluded from this game.\n\nTo solve these issues, ThomasV proposes bundling the prepayment and main payment in the same BOLT-11 invoice. The semantics of bundled payments would require the receiver to wait for all HTLCs of both payments to arrive before fulfilling the HTLCs of the prepayment. If the main payment does not arrive, they should fail the prepayment with a Multi-Path Payments (MPP) timeout. Once both payments' HTLCs have arrived, the receiver fulfills the HTLCs of the prepayment and broadcasts their on-chain transaction. It should be noted that the main payment can still fail if the sender never reveals the preimage.\n\nThomasV acknowledges that this proposal doesn't prevent the service provider from stealing the prepayment, but states that this is already a risk in the current system. The proposal aims to level the field in terms of competition between lightning service providers. Currently, using Loop requires a dedicated client, and competitors without an established user base running a dedicated client are exposed to the mining fee attack. ACINQ, the company ThomasV addresses directly, would also benefit from this proposal as it would make their pay-to-open service fully non-custodian, potentially avoiding compliance issues under European MICA regulation.\n\nLastly, ThomasV suggests that this change should be implemented in BOLT-11 rather than using BOLT-12 or onion messages. He argues that there's no need to introduce new messages when the desired functionality can be achieved in a non-interactive way.\n\nOverall, ThomasV's proposal aims to address specific limitations and vulnerabilities within the current Lightning Network system, providing a solution that could improve competition between lightning service providers and potentially offer more non-custodian options.",
      "summaryeli15": "Good morning! Let me break down the proposal for you. \n\nFirstly, the proposal suggests extending BOLT-11, which is a protocol used in the Lightning Network, a payment channel network built on top of the Bitcoin blockchain. BOLT-11 is used to create and process payment invoices.\n\nThe proposal's main objective is to allow invoices to contain two bundled payments with distinct preimages and amounts. This is because there are certain services, like submarine swaps and JIT (Just-in-Time) channels, that require a prepayment of a mining fee before a non-custodian exchange can take place.\n\nIn both cases, the service provider receives a Hashed Time Lock Contract (HTLC) for which they don't have the preimage. They need to send funds on-chain (to the channel or submarine swap funding address) and wait for the client to reveal the preimage when they claim the payment. However, since there is no guarantee that the client will actually claim the payment, service providers need to ask for prepayment of mining fees.\n\nCurrently, services that use dedicated client software can ask for prepayment, like Loop by Lightning Labs. But competitors who don't require dedicated wallets, such as the Boltz exchange, can't do that. This leaves Boltz vulnerable to Denial-of-Service (DoS) attacks where attackers force them to pay on-chain fees.\n\nIn the case of JIT channels, providers who want to protect themselves against mining fee attacks need to ask for the preimage of the main payment before opening the channel. However, this makes them become the custodian of the funds, which has legal implications under European MICA regulation.\n\nTo solve these issues, the proposal suggests bundling the prepayment and main payment in the same BOLT-11 invoice. The semantics of bundled payments would work like this:\n\n1. The invoice contains two preimages and two amounts: prepayment and main payment.\n2. The receiver waits until all HTLCs of both payments have arrived before fulfilling the HTLCs of the pre-payment. If the main payment doesn't arrive, they fail the pre-payment with a MPP (Multi-Path Payments) timeout.\n3. Once the HTLCs of both payments have arrived, the receiver fulfills the HTLCs of the prepayment and broadcasts their on-chain transaction. The main payment can still fail if the sender never reveals the preimage.\n\nIt's important to note that while this proposal helps level the playing field for lightning service providers, it doesn't prevent the service provider from stealing the pre-payment, although that is already a possibility today.\n\nThe proposal also suggests that ACINQ, a company involved in the Lightning Network, would benefit from this change as it would allow them to make their pay-to-open service fully non-custodian. Currently, their pay-to-open service used by Phoenix may fall under the scope of European MICA regulation, which they should consider a serious issue.\n\nLastly, the proposal suggests implementing this change in BOLT-11 rather than using BOLT-12 or onion messages. The reasoning behind this is to keep things simple and avoid introducing new messages when the desired functionality can be achieved in a non-interactive way.\n\nI hope that gives you a clear understanding of the proposal! Let me know if you have any further questions.",
      "title": "Proposal: Bundled payments",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003977.html"
    }
  ]
}