{
  "summary": [
    {
      "summary": "The text after the asterisk discusses the progress and future of the Bitcoin Contracting Primitives Working Group (WG), along with other related initiatives. The author reflects on their initial intention to dedicate 20% of their time to the effort, but acknowledges that their focus has shifted to working on Lightning Network development. They express the opinion that the smooth operation and scalability of Lightning Network is more critical for Bitcoin's survival. The author also highlights the importance of a small group of technical historians and archivists to assess, collect, and preserve consensus change proposals. They invite those interested in maintaining and nurturing the Bitcoin Contracting Primitives WG or collaborating with other initiatives to reach out. The author ends with a note on the interest they have received from R&D non-profits, individuals, and VC firms regarding soft forks and covenants in the Bitcoin space.",
      "summaryeli15": "The author of the post is providing an update on the progress of a community process for specifying covenants in the Bitcoin network. The goal of the process is to establish a consistent framework to evaluate covenant proposals and foster consensus changes beyond the boundaries of Bitcoin Core. Other complementary initiatives, such as the bitcoin-inquisition fork and the archiving of all covenant proposals under the Optech umbrella, have also been undertaken. However, the author acknowledges that they have not been able to dedicate as much time to the process as initially intended, due to their focus on Lightning development. They emphasize the importance of prioritizing the robustness of the Lightning Network for Bitcoin's survival, but still recognize the value of covenant changes and incremental improvements to Bitcoin Script. The author invites others to take on the maintenance and nurturing of the Bitcoin Contracting Primitives WG and collaborate on workshops and research in this area. They also highlight the need for technical historians and archivists to assess and preserve consensus change proposals, along with QA developers to conduct thorough testing. The author concludes by expressing their willingness to support individuals who are committed to working on soft forks and covenants in the Bitcoin space.",
      "title": "On the experiment of the Bitcoin Contracting Primitives WG and marking this community process \"up for grabs\"",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021786.html"
    },
    {
      "summary": "The text discusses the implementation of a blinded version of the 2-of-2 Schnorr Musig2 protocol for statechains. In this implementation, one of the parties (party 1) is fully blinded and does not learn the aggregate public key, aggregate signature, or the message being signed. The security of the blinded statechain is based on trusting the statechain server to report the number of partial signatures it has generated, rather than trusting it to enforce rules on what it has signed.\n\nThe text then describes the operation of the 2-of-2 musig2 protocol, involving the generation of private and public keys. To blind party 1 from learning the full public key or final signature, certain modifications are proposed. These modifications include performing key aggregation and nonce aggregation only by party 2, with party 1 sending relevant data to party 2. Party 2 then computes the challenge and sends it to party 1 for the computation of the partial signature.\n\nThe author seeks comments and feedback on these modifications and any potential issues.",
      "summaryeli15": "We are implementing a version of a cryptographic protocol called 2-of-2 Schnorr Musig2 for statechains. In this version, the server (party 1) will be \"blinded,\" meaning it will hold a private key necessary to generate signatures, but it will not learn the aggregate public key, aggregate signature, or the message being signed. The security of this system relies on the server reporting the number of partial signatures it has generated for a particular key, rather than trusting it to enforce rules on what it has signed in an unblinded case. The full set of signatures will be verified client-side.\n\nThe Schnorr Musig2 protocol works by generating private keys and public keys for each party involved. These keys are aggregated to create a shared public key. To sign a message, each party generates a random number and a corresponding point on an elliptic curve. These numbers and points are aggregated, and a \"challenge\" value is computed based on the shared public key, the aggregated points, and the message. Each party then computes their individual signature component using the challenge and their private key.\n\nIn the case of blinding the server (party 1), we make a few modifications. Party 1 no longer needs to independently compute the challenge and can receive it from party 2. Key aggregation is performed only by party 2, and nonce aggregation is also performed by party 2. Party 1 only needs to send its key and nonce to party 2. By implementing these changes, party 1 will not learn the final signature or the message being signed. The text concludes by asking for comments or potential issues with this approach.",
      "title": "Blinded 2-party Musig2",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021792.html"
    },
    {
      "summary": "The text explains a mathematical demonstration of a method to compute blinding factors that allows for efficient routing in a payment network. The goal is to ensure that nodes along the route only need to know one blinding factor, and the receiver also only needs to know one. The text presents different scenarios, starting with the simplest case where the sender and receiver are directly connected. In this case, the sender chooses a random error factor and constructs an onion encrypted with this factor, which the receiver can claim by revealing a related value. \n\nThe text then discusses the case where there is an intermediate node called Carol. In this situation, the sender still needs to choose an error factor but also needs to generate two other factors such that their sum equals the error factor. The sender encrypts the onion with the error factor for the receiver and another factor for Carol. The process continues as each intermediate node adds its blinding factor and passes on the onion to the next node. This ensures that the receiver cannot distinguish between receiving the payment directly or through a sequence of intermediate nodes. \n\nThe text then introduces the concept of a Trampoline node, which is a node that routes payments but does not know the final destination. In this case, the sender encrypts the onion with the error factor for the receiver and additional factors for Carol and the next Trampoline hop. Carol decrypts the onion, finds a route to the next Trampoline, and creates a new onion for the subsequent hop. This process continues until the payment reaches the ultimate receiver. Again, the receiver cannot differentiate between receiving the payment through a Trampoline or directly. \n\nIn claiming the payment, each node along the route has enough information to claim its incoming payment, and only the ultimate sender knows a blinding factor that allows it to recover the secret value.",
      "summaryeli15": "This text is discussing a method called blinding factors that allows for secure communication between nodes in a network. It explains how these blinding factors can be used to protect the privacy of the sender and receiver in various scenarios. \n\nIn the simplest case, the sender and receiver are directly connected. The sender generates a random blinding factor \"e\" and constructs an encrypted message that can only be decrypted by the receiver. The sender then sends this message to the receiver, along with a point that represents the blinding factor \"e\" multiplied by a constant \"G\". The receiver can claim the message by revealing the sum of their secret factor \"r\" and the blinding factor \"e\".\n\nIn a more complex scenario where an intermediate node is involved, the sender must generate two blinding factors \"c\" and \"d\" such that their sum equals the original blinding factor \"e\". The sender encrypts the message with the factor \"e\" for the receiver and also encrypts the factors \"d\" for the intermediate node. Each intermediate node adds its own blinding factor multiplied by the constant \"G\" to the message and passes it on to the next node. By rearranging the equation, the receiver cannot differentiate whether it received the message directly or through an intermediate node.\n\nThe text then describes a situation where a trampoline node is used, which is a type of intermediate node. The process is similar, but the trampoline node is not aware that it is the final node for the receiver. The sender encrypts the message with the receiver's blinding factor for the receiver and with the factors \"d\" and the identifier of the final trampoline node for the intermediate node. The intermediate node then finds a route to the final node and adds its own blinding factor multiplied by the constant \"G\" to the message before forwarding it. Again, the equation is rearranged in a way that the receiver cannot tell if the message came through a trampoline node or not.\n\nOverall, this method ensures that all nodes involved in the communication process have sufficient information to claim their respective parts of the message while maintaining the privacy of the sender and receiver.",
      "title": "Computing Blinding Factors in a PTLC and Trampoline World",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html"
    },
    {
      "summary": "LNbits, a team specializing in Lightning Network applications, recently discovered an exploit that allows attackers to create fraudulent balances by manipulating invoice handling. The team has patched the vulnerability in LNbits version 0.10.5 and advises immediate updates. The attack involves inserting a payment hash from one payment into a different payment, essentially tricking the system into treating them as the same. The critical part of this exploit is that payment hashes only commit to the preimage and not to any payment details like the amount. To mitigate this vulnerability, backends should use unique \"checking ids\" or implement additional checks to ensure invoice integrity. This incident highlights the sophistication of LN-savvy attackers and emphasizes the importance of understanding the limitations of payment hashes, which should be referred to as \"preimage hashes\" instead.",
      "summaryeli15": "LNbits, a team specializing in Lightning Network applications, recently discovered an exploitable flaw in how invoices are processed internally. They have released a patch to fix this issue in their latest version, 0.10.5, and are urging users to update as soon as possible. The exploit involves an attacker creating a malicious invoice that tricks the system into treating it as a legitimate payment. By manipulating payment hashes, the attacker can generate balances out of thin air. This vulnerability may also affect other Lightning applications, such as custodial wallets and payment processors. To prevent similar attacks, developers should use unique checking IDs or implement additional checks to ensure invoice integrity. It's important to note that the payment hash in an invoice only serves as a preimage hash and does not commit to payment details like amount or pubkey. Therefore, it is crucial for developers to understand this distinction and refer to it as a preimage hash.",
      "title": "Potential vulnerability in Lightning backends: BOLT-11 \"payment hash\" does not commit to payment!",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html"
    },
    {
      "summary": "In this message, the sender is sharing a side project they have been working on related to collecting data on the lightning network. They explain that the project aims to track the evolution of the network, evaluate solution proposals, and support university research that lacks access to real data. They mention that the collected information can be shared among people to assess ideas and proposals. The sender provides links to a more detailed idea document, an experimental explorer, and a public Graphql API. They conclude the message by expressing their hope that this project will be helpful to someone.",
      "summaryeli15": "Vincent is sharing a side project where he collects data on the lightning network, which is a technology for making fast and cheap transactions using Bitcoin. He wants to understand how the network is evolving and test new solutions. He also wants to support university research by providing them with real data. Vincent has detailed his idea in a document and created an experimental explorer and an API for accessing the data. He hopes that this project will be helpful to others.",
      "title": "An Open Source Framework to Collect Lightning Network Metrics",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004011.html"
    },
    {
      "summary": "The text provides a summary of discussions from a specification meeting regarding various topics related to the Lightning Network protocol. The first section focuses on Package Relay, discussing proposals for package types, relay fees, and anchoring strategies. The second section explores Taproot, highlighting changes in the protocol related to anchors and NUMS points. The third section delves into Gossip, comparing different versions and discussing the binding of taproot outputs. The fourth section covers Multi-Sig Channel Parties, presenting different approaches for implementing multi-sig for one channel party. The fifth section discusses PTLCs (Point Time Lock Contracts) and options for addressing redundant overpayment. The sixth section introduces a hybrid approach to mitigating channel jamming, combining monetary, reputation, and scarce resource solutions. The seventh section explores reputation systems as a means to prevent jamming and outlines the use of protected and general resource buckets. The eighth section proposes simplifying commitments to streamline the state machine and introduces the concept of turn-taking. The ninth section suggests the need for versioning in the protocol specification for improved compatibility and readability. The final section touches on async payments and trampoline routing, highlighting the benefits of blinded payments and the use of trampoline nodes to facilitate routing.",
      "summaryeli15": "The text discusses various topics related to the Lightning Network protocol. One topic is the current proposal for package relay, which aims to improve the process of adding transactions to the mempool. Another topic is the introduction of V3 transactions and ephemeral anchors, which would allow for zero fee commitment transactions and provide greater flexibility in transaction structures. The text also mentions the concept of a cluster mempool, which could improve block selection and transaction sorting. Additionally, there are discussions about Taproot, gossip versions, reputation-based mechanisms to mitigate channel jamming attacks, and the possibility of implementing simplified commitments to simplify the state machine. The text concludes with a discussion about versioning and modularization of the protocol specification.",
      "title": "LN Summit 2023 Notes",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004014.html"
    }
  ]
}